#pragma once
#include <map>
#include <string>
#include <concepts>
#include <functional>
#include <thread>
#include <memory>
#include <mutex>
#include <condition_variable>
#include <exception>
#include <chrono>
#include <queue>
#include "PacketTypes/header.h"
#include "FastDDS.h"

/// @brief Registers the topic topicName on the communication manager manager with type type
/// @param type Type the topic should use
/// @param topicName The name of the topic
/// @param manager The instance of the communication manager that should be used
#define REGISTER_TYPE_TO_MANAGER(type, topicName, manager)\
manager.registerTopic<type##PubSubType>(topicName)

class CommunicationManager
{
public:
    CommunicationManager(std::string_view hostname, bool isServer = false);
    ~CommunicationManager();

    /// @brief Register a topic that uses data type T. It is recommended to use the REGISTER_TYPE_TO_MANAGER macro
    /// instead of directly using this function.
    /// @param T The data type the topic uses. Must inherit from eprosima::fastdds::dds::TopicDataType.
    /// The name of the data type will end in PubSubType if generated by fast-dds gen
    /// @param topicName The name of the topic
    template <typename T>
    requires std::derived_from<T, eprosima::fastdds::dds::TopicDataType>
    void registerTopic(std::string topicName);

    /// @brief Create a dataWriter attached to a given topic
    /// @param topicName The topic name to attach the dataWriter to. Must
    /// have been created using registerTopic(...)
    /// @return The ID of the created data writer
    int addDataWriter(std::string topicName);

    template <typename T>
    requires std::copyable<T>
    void writeData(int writerID, T* data);

    /// @brief Adds a data reader that calls callback when data is recieved on the specified topic
    /// @tparam T The data type to be recieved
    /// @param topicName The name of the topic to listen to
    /// @param callback The callback called when data is recieved, It returns void and takes a pointer to T
    template <typename T>
    void addDataReader(std::string topicName, std::function<void(T*)> callback);
    

    /// @brief Stop the callback thread
    void shutdown();

private:
    struct IPData
    {
        std::string ip;
        uint32_t port;
    };

    struct DataContainer
    {
        int writeID;
        void* data;
    };

    eprosima::fastdds::dds::DomainParticipant* _participant;
    eprosima::fastdds::dds::Publisher* _publisher;
    eprosima::fastdds::dds::Subscriber* _subscriber;
    std::map<std::string, eprosima::fastdds::dds::Topic*> _topics;
    std::vector<eprosima::fastdds::dds::DataWriter*> _writers;
    std::vector<eprosima::fastdds::dds::DataReader*> _readers;
    std::vector<std::unique_ptr<eprosima::fastdds::dds::WaitSet>> _waitSets;
    std::map<std::string, std::vector<std::function<void(void*)>>> _callbacks;
    std::queue<DataContainer> _data;

    std::thread _readerThread;
    std::mutex _readerMux;
    std::mutex _callbackMux;
    std::condition_variable _readerCV;
    std::condition_variable _callbackCV;
    bool _readerFree;
    bool _callbackFree;
    bool _run;

    std::thread _writerThread;
    std::mutex _writerMux;
    std::condition_variable _writerCV;
    bool _writerFree;

    void _dataRecievedHandler();
    eprosima::fastdds::dds::DomainParticipant* _createServerParticipant(std::string_view hostname);
    eprosima::fastdds::dds::DomainParticipant* _createClientParticipant(std::string_view hostname);
    IPData _parseIP(std::string_view hostname);
    void _writeWorker();

};

class HostnameException : public std::runtime_error
{
public:
    HostnameException(const std::string& what) : std::runtime_error(what) {}
};

template <typename T>
requires std::derived_from<T, eprosima::fastdds::dds::TopicDataType>
void CommunicationManager::registerTopic(std::string topicName)
{
    eprosima::fastdds::dds::TypeSupport type(new T());
    type.register_type(_participant, type.get_type_name());
    auto* topic = _participant->create_topic(topicName, type.get_type_name(), eprosima::fastdds::dds::TOPIC_QOS_DEFAULT);

    _topics.insert(std::make_pair(topicName, topic));

    // Create vector for callbacks on this topic
    std::unique_lock callbackLock(_callbackMux);
    _callbackCV.wait(callbackLock,[this](){ return _callbackFree; });
    _callbackFree = false;
    _callbacks.emplace(topicName, 0);
    _callbackFree = true;
    callbackLock.unlock();
    _callbackCV.notify_all();
}

template <typename T>
requires std::copyable<T>
inline void CommunicationManager::writeData(int writerID, T *data)
{
    DataContainer d = {writerID, nullptr};
    d.data = std::malloc(sizeof(*data));
    std::memcpy(d.data, data, sizeof(*data));

    std::unique_lock lck(_writerMux);
    _writerCV.wait(lck, [this](){ return _writerFree; });
    _writerFree = false;
    _data.push(d);
    _writerFree = true;
    _writerCV.notify_all();
}

template <typename T>
void CommunicationManager::addDataReader(std::string topicName, std::function<void(T *)> callback)
{
    std::unique_lock lck(_readerMux);
    _readerCV.wait(lck, [this](){ return _readerFree; });
    _readerFree = false;

    const auto& topic = _topics.at(topicName);
    auto qos = eprosima::fastdds::dds::DATAREADER_QOS_DEFAULT;
    qos.reliability().kind = eprosima::fastdds::dds::RELIABLE_RELIABILITY_QOS;
    qos.history().kind = eprosima::fastdds::dds::HistoryQosPolicyKind::KEEP_ALL_HISTORY_QOS;
    auto* reader = _subscriber->create_datareader(topic, qos);
    _readers.push_back(reader);

    auto cb = std::function([callback](void* data)
        {
            Header* head = (Header*)data;
            auto now = std::chrono::system_clock::now();
            auto epoch = now.time_since_epoch();
            auto mill = std::chrono::duration_cast<std::chrono::milliseconds>(epoch);
            head->timeRec(mill.count());
            callback((T*)data);
        }
    );

    _callbacks.at(topicName).push_back(cb);

    auto* w = new eprosima::fastdds::dds::WaitSet;
    _waitSets.emplace_back(w);
    eprosima::fastdds::dds::StatusCondition& con = reader->get_statuscondition();
    con.set_enabled_statuses(eprosima::fastdds::dds::StatusMask::data_available());
    w->attach_condition(con);

    _readerFree = true;
    lck.unlock();
    _readerCV.notify_all();
}
